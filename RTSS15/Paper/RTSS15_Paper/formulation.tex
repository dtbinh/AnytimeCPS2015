\subsection{System Model}
\label{formulation}

Consider a hexarotor, which is an autonomous flying robot with six rotors, shown in Fig.~\ref{fig:hexarotor}.
The state $\stPt$ of the hexarotor is made of its 3D position and 3D velocity.
The input $\inpPt$ to the robot consists of the desired pitch and roll angles, and the desired thrust.
The hexarotor's mission is to fly a pre-defined pattern $\stPt_{ref}$, such as the one shown in Fig.~\ref{fig:hexarotor}.
The dynamics of the hexarotor, relating the time-evolution of its state to the current state and input, can be approximated by the following Linear Time-Invariant (LTI) ODE [??]:
\begin{equation}
\dot{x}(t) = A_{c}x(t)+B_{c}u(t)+w_{c}(t)  \label{eq:plant-cont-model}
\end{equation}
where $x\in \Re^{n}$ is the state constrained to lie in a set $\stSet \subset \Re^n$, 
$\inpPt\in\Re^{m}$ is the control input constrained to lie in a set $\inpSet \subset \Re^m$,
and $w_{c}\in\Re^{n}$ is the process noise assumed to lie in a set $\Wc \subset \Re^n$. 
LTIs model a wide range of systems, and our results apply to arbitrary LTIs of the form given in \eqref{eq:plant-cont-model} with polyhedral constraint sets $\stSet,\inpSet$ and $\Wc$.

\subsection{Time-Triggered Actuation and Discretized Dynamics}
For flight the hexarotor needs to determine its current position and speed, i.e., it needs to produce an \emph{estimate} of its current state $\stPt$.
It does so by taking a video during flight through a downward facing camera, detecting and tracking features across frames, and deducing its own position relative to these features.
The camera captures a new frame every $T > 0$ seconds, thus resulting in periodic measurements at instants $t_{s,k}=kT$,
where $k\in\Ne$.
See Fig.~\ref{fig:senseActuate}.
The sampled measurement is fed to the estimator that computes the state
estimate $\hat{x}_{k}\defeq\hat{x}(t_{s,k})$ with the desired
accuracy $\sAccu_k$ \emph{determined by the controller in the previous time step}. 
The controller then uses this state estimate
to compute the control input $u_{k}$ as well as decide on the desired
state estimate's delay and accuracy contract $(\sDelay_{k+1},\sAccu_{k+1})$ for the next step. 
This control is applied to the physical system according to \eqref{eq:plant-cont-model} at instant $t_{a,k} = t_{s,k}+\sDelay_k + \tau_k$, where $\tau_k$ is the time it takes to compute the input. 

In our setting, the controller has access to the delay-error curve of the estimator, and makes contract selections \emph{from that curve}. 
This curve is obtained offline as explained in Section \ref{codesign}, and detailed in Section \ref{delayErrorCurve}.

\subsection{Control Performance}
The goal of the controller is twofold: it needs to ensure that the reference pattern is adhered to as closely as possible, and that the energy consumed to fly this pattern is minimized.
Thus we may define two (stage) cost functions: first, $\ell(\stPt, \inpPt) = (\stPt - \stPt_{ref})^TQ(\stPt - \stPt_{ref})$ defines a weighted error between the actual state and the reference state $\stPt_{ref}$, where $Q$ is a positive semidefinite matrix.
Second, $\pi(\sDelay)$ captures the average power consumed to perform an estimation of duration $\sDelay$. 
This power information is collected offline during the estimator profiling phase.

The total cost function that the controller minimizes is then
\(
J=\sum_{k=0}^{\infty}\left(\ell(\stPt_k,\inpPt_k)+\pi(\sDelay_k)\right)
\).
The paper's formulation holds for much more general stage cost functions.
These stage cost functions are chosen by the designer to achieve a desired control performance.

The order of sensing\textendash{}computing\textendash{}actuating and
their timing are illustrated in the diagram in Fig.~\ref{fig:senseActuate}.
We remark that in each step $k\geq0$, the estimation accuracy $\sAccu_k$
and hence the delay $\sDelay_k$ are already decided in the previous
step and known to the controller. 
The previous control input $u_{k-1}$
is still used until $t_{a,k}$ when the new control input $u_{k}$
is computed and applied by the controller. 
The controller also chooses
the next desired accuracy $\sAccu_{k+1}$ and delay $\sDelay_{k+1}$
to be used in the next step $k+1$. 
In the first step $k=0$, the
initial accuracy $\sAccu_0$, the initial delay $\sDelay_0$, and
the initial control input $u_{-1}$ are chosen by the designer.

\begin{equation}
x_{k+1}=Ax_{k}+B_{1}(\sDelay[k])u_{k-1}+B_{2}(\sDelay[k])u_{k}+w_{k}, k\geq0\label{eq:disc-dynamics} %deleted \qquad from infront of k\geq0
\end{equation}
in which
%\begin{eqnarray*}
%A=\eu^{A_{c}T}, \quad
%w_{k}%=\int_{t_{s,k}}^{t_{s,k+1}}\eu^{A_{c}(t_{s,k+1}-t)}w_{c}(t)\diff t \nonumber \\
%=\int_{0}^{T}\eu^{A_{c}(T-t)}w_{c}(t_{s,k}+t)\diff t \\
%B_{1}(\sDelay[k])%=\int_{t_{s,k}}^{t_{a,k}}\eu^{A_{c}(t_{s,k+1}-t)}B_{c}\diff t
%\!=\!\int_{0}^{\sDelay[k]}\eu^{A_{c}(T-t)}B_{c}\diff t,\,
%B_{2}(\sDelay[k])%=\int_{t_{a,k}}^{t_{s,k+1}}\eu^{A_{c}(t_{s,k+1}-t)}B_{c}\diff t
%\!=\!\int_{\sDelay[k]}^{T}\eu^{A_{c}(T-t)}B_{c}\diff t \text.
%\end{eqnarray*}
Here $w_{k}$ is the accumulated process noise during the interval.
Because $w_{c}(t)$ is constrained in the compact and convex set $\Wc_{c}$
and $T$ is finite, we can find a compact and convex set $\Wc$
that bounds $w_{k}$, namely
\begin{equation}
w_{k}\in\Wc\qquad\forall k\geq0\text{.}\label{eq:disturb-constraint}
\end{equation}
%We remark 
Note that both the current control $u_{k}$ and the previous
control $u_{k-1}$ appear %in the dynamics 
in \eqref{disc-dynamics}.
Furthermore, the input matrices $B_{1}(\sDelay[k])$ and $B_{2}(\sDelay[k])$
depend on the delay $\sDelay[k]$; hence $\sDelay[k]$ is also an
input to the dynamics. The estimation accuracy $\sAccu[k]$ does not
appear in the equation because it only affects the state estimate
$\hat{x}_{k}$ %which is
used by the controller to compute $u_{k}$;
therefore $\sAccu[k]$ indirectly affects the dynamics via the control
input.







