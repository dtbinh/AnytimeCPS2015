\section{Related Work}
\label{related}

% Note, our approach to 
%: algorithms that have a range of runtimes, and each runtime is associated with some quality of the algorithm's output.
%Another class of anytime algorithms is called \emph{interruptible}: these are algorithms that can be interrupted at any time during their execution, and they return a usable output.
%The difference between contract and interruptible algorithms is that when the latter are interrupted, the accuracy of the output is not known beforehand to the interruptor.
%Contract algorithms, on the other hand, offer a \emph{finite} number of (accuracy, delay) operating points, which constitute the `contracts'. 
%When the \emph{requestor} (e.g., the controller) requests a contract, it therefore knows the accuracy with which the answer is returned.
%This is important for controllers, which need to know a bound on the estimate error in order to \emph{guarantee} stability of the system and achieve functional goals.
Anytime algorithms \cite{boddy} are a special class of algorithms that can be interrupted during their execution and still return a usable solution, usually with a monotonically improving solution with time. Contract algorithms \cite{zilbersteinAImag} are one class of \emph{anytime} algorithms where the time by which the algorithm has to finish its execution time is known /textit{aprior}. Our approach, while similar to contract algorithms in the timing aspect, differs signifcantly as the meaning of a contract expands to including both time and quality of the solution (estimation error in our case).
%Anytime algorithms for sensor interpretation and path planning in more complex systems were studied in \cite{zilberstein, planningalgorithms}. 

Anytime algorithms have been studied for graph search \cite{maxim}, evaluation of belief networks \cite{wellman} and GPU architectures \cite{RTSSanytime}.

As overloaded real-time systems are becoming increasingly common, anytime algorithms for control have become a topic of research interest. Most notably, Quevedo and Gupta \cite{sequence}, Bhattacharya and Balas \cite{balas}, and Fontanelli et al. \cite{fontanelli} have contributed on the topic. Our approach differs significantly from these works as the anytime computation assumption is on the perception-and-estimation algorithm and our controller is a robust controller which can switch between different operating modes of the anytime estimator. Also, while most of these works require either access to the full state of the system or have a fast estimator giving them the state estimate \cite{balas}, our algorithm accounts for the computation time/error of the perception-and-estimation algorithms that are common in autonomous systems.

In real-time systems, recent work \cite{FrehseHQW14_Formal} uses Typical Worst Case Analysis of the software and Logical Execution Time semantics to provide the controller with knowledge of the timing characteristics of the implementation.
Our work, by contrast, profiles the estimation software directly to obtain timing and accuracy information. Whereas \cite{FrehseHQW14_Formal} is concerned with formal verification of a given controller, we \emph{design} controllers to take advantage of delay/accuracy trade-offs in real-time. The effect of increasing computation time of a task on performance of a UAV has been explored in \cite{overbook} by using a resource allocation algorithm similar to QRAM \cite{qram}. Our work differs from this as we consider the execution time of a task, the estimator, which directly related to the control performance of a closed loop system and also formulate a control problem around it that provides mathematical guarantees on the performance of the closed loop system.

Also, in the field of computer architecture approximate computing approaches \cite{loop-perf,rely,npu} have been studied, seeking time or energy
savings by performing a computation approximately instead of precisely. While
anytime algorithms and approximate computing share a high-level goal,
approximate computing approaches are run-to-completion and also lack a feedback
mechanism to permit computation and resources to be balanced dynamically. Additionally the time and energy scale that our approach works at is much higher than what approximate computing looks at.

